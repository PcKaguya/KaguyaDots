// monitors.go
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

type HyprctlMonitor struct {
	ID              int     `json:"id"`
	Name            string  `json:"name"`
	Description     string  `json:"description"`
	Make            string  `json:"make"`
	Model           string  `json:"model"`
	Serial          string  `json:"serial"`
	Width           int     `json:"width"`
	Height          int     `json:"height"`
	RefreshRate     float64 `json:"refreshRate"`
	X               int     `json:"x"`
	Y               int     `json:"y"`
	ActiveWorkspace struct {
		ID   int    `json:"id"`
		Name string `json:"name"`
	} `json:"activeWorkspace"`
	Scale      float64 `json:"scale"`
	Transform  int     `json:"transform"`
	Focused    bool    `json:"focused"`
	DpmsStatus bool    `json:"dpmsStatus"`
}

type MonitorConfig struct {
	Name        string  `json:"name"`
	Resolution  string  `json:"resolution"`
	Position    string  `json:"position"`
	Scale       float64 `json:"scale"`
	RefreshRate float64 `json:"refreshRate"`
}

// GetMonitors retrieves all connected monitors using hyprctl
func (a *App) GetMonitors() ([]HyprctlMonitor, error) {
	cmd := exec.Command("hyprctl", "monitors", "-j")
	output, err := cmd.Output()
	if err != nil {
		return nil, fmt.Errorf("failed to execute hyprctl: %w", err)
	}

	var monitors []HyprctlMonitor
	if err := json.Unmarshal(output, &monitors); err != nil {
		return nil, fmt.Errorf("failed to parse monitors JSON: %w", err)
	}

	return monitors, nil
}

// SaveMonitorConfig saves the monitor configuration to ~/.config/hypr/configs/monitors.conf
func (a *App) SaveMonitorConfig(configs []MonitorConfig) error {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return fmt.Errorf("failed to get home directory: %w", err)
	}

	configPath := filepath.Join(homeDir, ".config", "hypr", "configs", "monitors.conf")

	// Ensure the directory exists
	configDir := filepath.Dir(configPath)
	if err := os.MkdirAll(configDir, 0755); err != nil {
		return fmt.Errorf("failed to create config directory: %w", err)
	}

	// Build the configuration content
	var builder strings.Builder
	builder.WriteString("# Monitor Configuration\n")
	builder.WriteString("# Generated by KaguyaDots Helper\n\n")

	for _, config := range configs {
		// Format: monitor = name, resolution@refreshrate, position, scale
		line := fmt.Sprintf("monitor = %s, %s@%g, %s, %.2f\n",
			config.Name,
			config.Resolution,
			config.RefreshRate,
			config.Position,
			config.Scale,
		)
		builder.WriteString(line)
	}

	// Write to file
	if err := os.WriteFile(configPath, []byte(builder.String()), 0644); err != nil {
		return fmt.Errorf("failed to write config file: %w", err)
	}

	return nil
}

// ReloadHyprland reloads the Hyprland configuration
func (a *App) ReloadHyprland() error {
	cmd := exec.Command("hyprctl", "reload")
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to reload Hyprland: %w", err)
	}
	return nil
}

// GetMonitorConfig reads the current monitor configuration from monitors.conf
func (a *App) GetMonitorConfig() (string, error) {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return "", fmt.Errorf("failed to get home directory: %w", err)
	}

	configPath := filepath.Join(homeDir, ".config", "hypr", "configs", "monitors.conf")

	content, err := os.ReadFile(configPath)
	if err != nil {
		if os.IsNotExist(err) {
			return "", nil // Return empty string if file doesn't exist
		}
		return "", fmt.Errorf("failed to read config file: %w", err)
	}

	return string(content), nil
}

// ParseMonitorConfig parses the monitors.conf file and returns structured data
func (a *App) ParseMonitorConfig() ([]MonitorConfig, error) {
	content, err := a.GetMonitorConfig()
	if err != nil {
		return nil, err
	}

	if content == "" {
		return []MonitorConfig{}, nil
	}

	var configs []MonitorConfig
	lines := strings.Split(content, "\n")

	for _, line := range lines {
		line = strings.TrimSpace(line)
		// Skip comments and empty lines
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}

		// Parse monitor line: monitor = name, resolution@refreshrate, position, scale
		if strings.HasPrefix(line, "monitor") {
			parts := strings.Split(line, "=")
			if len(parts) < 2 {
				continue
			}

			values := strings.Split(parts[1], ",")
			if len(values) < 4 {
				continue
			}

			config := MonitorConfig{
				Name:     strings.TrimSpace(values[0]),
				Position: strings.TrimSpace(values[2]),
			}

			// Parse resolution and refresh rate
			resAndRate := strings.Split(strings.TrimSpace(values[1]), "@")
			if len(resAndRate) >= 1 {
				config.Resolution = resAndRate[0]
			}
			if len(resAndRate) >= 2 {
				fmt.Sscanf(resAndRate[1], "%f", &config.RefreshRate)
			}

			// Parse scale
			fmt.Sscanf(strings.TrimSpace(values[3]), "%f", &config.Scale)

			configs = append(configs, config)
		}
	}

	return configs, nil
}

// GetAvailableResolutions returns common resolutions for a monitor
func (a *App) GetAvailableResolutions() []string {
	return []string{
		"1920x1080",
		"2560x1440",
		"3840x2160",
		"1920x1200",
		"2560x1600",
		"3440x1440",
		"1680x1050",
		"1366x768",
		"1280x720",
		"preferred", // Use monitor's preferred resolution
	}
}

// TestMonitorConfig temporarily applies monitor config without saving
func (a *App) TestMonitorConfig(config MonitorConfig) error {
	configStr := fmt.Sprintf("%s,%s@%g,%s,%.2f",
		config.Name,
		config.Resolution,
		config.RefreshRate,
		config.Position,
		config.Scale,
	)

	cmd := exec.Command("hyprctl", "keyword", "monitor", configStr)
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to test monitor config: %w", err)
	}

	return nil
}
