package main

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// Animation represents a single animation configuration
type Animation struct {
	Name    string `json:"name"`
	Enabled bool   `json:"enabled"`
	Speed   string `json:"speed"`
	Curve   string `json:"curve"`
	Style   string `json:"style"`
}

// Bezier represents a bezier curve definition
type Bezier struct {
	Name string `json:"name"`
	X0   string `json:"x0"`
	Y0   string `json:"y0"`
	X1   string `json:"x1"`
	Y1   string `json:"y1"`
}

// AnimationConfig holds all animations and bezier curves
type AnimationConfig struct {
	Animations []Animation `json:"animations"`
	Beziers    []Bezier    `json:"beziers"`
}

// GetAnimationsPath returns the path to animations.conf
func (a *App) GetAnimationsPath() string {
	home, err := os.UserHomeDir()
	if err != nil {
		return ""
	}
	return filepath.Join(home, ".config", "hypr", "configs", "animations.conf")
}

// ReadAnimations reads and parses the animations.conf file
func (a *App) ReadAnimations() AnimationConfig {
	path := a.GetAnimationsPath()
	fmt.Println("ReadAnimations start")

	file, err := os.Open(path)
	if err != nil {
		if os.IsNotExist(err) {
			fmt.Println("File does not exist, returning empty config")
			return AnimationConfig{
				Animations: []Animation{},
				Beziers:    []Bezier{},
			}
		}
		fmt.Printf("Error opening file: %v\n", err)
		return AnimationConfig{
			Animations: []Animation{},
			Beziers:    []Bezier{},
		}
	}
	defer file.Close()

	config := AnimationConfig{
		Animations: []Animation{},
		Beziers:    []Bezier{},
	}

	inAnimationBlock := false
	scanner := bufio.NewScanner(file)

	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())

		// Check if we're entering the animations block
		if strings.HasPrefix(line, "animations") && strings.Contains(line, "{") {
			inAnimationBlock = true
			continue
		}

		// Check if we're exiting the animations block
		if inAnimationBlock && strings.HasPrefix(line, "}") {
			inAnimationBlock = false
			continue
		}

		// Skip empty lines
		if line == "" {
			continue
		}

		// Only parse animation/bezier lines if we're inside the block
		if inAnimationBlock {
			// Check for commented animation lines
			isCommented := strings.HasPrefix(line, "#")
			actualLine := line
			if isCommented {
				actualLine = strings.TrimSpace(strings.TrimPrefix(line, "#"))
			}

			if strings.HasPrefix(actualLine, "animation") {
				if anim := parseAnimationLine(actualLine); anim != nil {
					// If the line was commented, mark animation as disabled
					if isCommented {
						anim.Enabled = false
					}
					config.Animations = append(config.Animations, *anim)
					fmt.Printf("Parsed animation: %s (commented: %v)\n", anim.Name, isCommented)
				}
			}

			// Beziers are not commented, skip if starts with #
			if !isCommented && strings.HasPrefix(line, "bezier") {
				if bez := parseBezierLine(line); bez != nil {
					config.Beziers = append(config.Beziers, *bez)
					fmt.Printf("Parsed bezier: %s\n", bez.Name)
				}
			}
		}
	}

	if err := scanner.Err(); err != nil {
		fmt.Printf("Scanner error: %v\n", err)
	}

	fmt.Printf("Animations: %d, Beziers: %d\n", len(config.Animations), len(config.Beziers))
	fmt.Println("ReadAnimations end")

	// Ensure we never return nil slices
	if config.Animations == nil {
		config.Animations = []Animation{}
	}
	if config.Beziers == nil {
		config.Beziers = []Bezier{}
	}

	return config
}

// WriteAnimations writes the animation configuration to file
func (a *App) WriteAnimations(config AnimationConfig) error {
	path := a.GetAnimationsPath()

	// Create directory if it doesn't exist
	dir := filepath.Dir(path)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	file, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("failed to create file: %w", err)
	}
	defer file.Close()

	writer := bufio.NewWriter(file)

	// Write header
	writer.WriteString("# Hyprland Animations Configuration\n")
	writer.WriteString("# Generated by KaguyaDots Helper\n\n")

	// Start animations block
	writer.WriteString("animations {\n")
	writer.WriteString("    enabled = true\n\n")

	// Write bezier curves
	if len(config.Beziers) > 0 {
		writer.WriteString("    # Bezier Curves\n")
		for _, bez := range config.Beziers {
			line := fmt.Sprintf("    bezier = %s, %s, %s, %s, %s\n",
				bez.Name, bez.X0, bez.Y0, bez.X1, bez.Y1)
			writer.WriteString(line)
		}
		writer.WriteString("\n")
	}

	// Write animations
	if len(config.Animations) > 0 {
		writer.WriteString("    # Animations\n")
		for _, anim := range config.Animations {
			line := formatAnimationLine(anim)
			// If animation is disabled, comment it out
			if !anim.Enabled {
				writer.WriteString("    # " + line + "\n")
			} else {
				writer.WriteString("    " + line + "\n")
			}
		}
	}

	// Close animations block
	writer.WriteString("}\n")

	if err := writer.Flush(); err != nil {
		return fmt.Errorf("failed to write file: %w", err)
	}

	return nil
}

// parseAnimationLine parses a single animation line
func parseAnimationLine(line string) *Animation {
	// Remove "animation = " prefix
	line = strings.TrimPrefix(line, "animation")
	line = strings.TrimSpace(line)
	line = strings.TrimPrefix(line, "=")
	line = strings.TrimSpace(line)

	// Split by comma
	parts := splitByComma(line)
	if len(parts) < 2 {
		return nil
	}

	anim := &Animation{
		Name:    strings.TrimSpace(parts[0]),
		Enabled: true, // Default to enabled when parsing
		Speed:   "",
		Curve:   "",
		Style:   "",
	}

	// Parse enabled flag
	if len(parts) > 1 {
		enabled := strings.TrimSpace(parts[1])
		anim.Enabled = enabled == "1" || enabled == "true"
	}

	// Parse speed
	if len(parts) > 2 {
		anim.Speed = strings.TrimSpace(parts[2])
	}

	// Parse curve
	if len(parts) > 3 {
		anim.Curve = strings.TrimSpace(parts[3])
	}

	// Parse style (optional)
	if len(parts) > 4 {
		// Join remaining parts in case style contains commas
		styleParts := parts[4:]
		anim.Style = strings.TrimSpace(strings.Join(styleParts, ","))
	}

	return anim
}

// parseBezierLine parses a single bezier line
func parseBezierLine(line string) *Bezier {
	// Remove "bezier = " prefix
	line = strings.TrimPrefix(line, "bezier")
	line = strings.TrimSpace(line)
	line = strings.TrimPrefix(line, "=")
	line = strings.TrimSpace(line)

	// Split by comma
	parts := splitByComma(line)
	if len(parts) < 5 {
		return nil
	}

	return &Bezier{
		Name: strings.TrimSpace(parts[0]),
		X0:   strings.TrimSpace(parts[1]),
		Y0:   strings.TrimSpace(parts[2]),
		X1:   strings.TrimSpace(parts[3]),
		Y1:   strings.TrimSpace(parts[4]),
	}
}

// formatAnimationLine formats an Animation into a config line
func formatAnimationLine(anim Animation) string {
	// Always format with full details, commenting handled by WriteAnimations
	if anim.Style != "" {
		return fmt.Sprintf("animation = %s, 1, %s, %s, %s",
			anim.Name, anim.Speed, anim.Curve, anim.Style)
	}

	return fmt.Sprintf("animation = %s, 1, %s, %s",
		anim.Name, anim.Speed, anim.Curve)
}

// splitByComma splits a string by comma, handling nested content
func splitByComma(s string) []string {
	var result []string
	var current strings.Builder

	for _, char := range s {
		if char == ',' {
			result = append(result, current.String())
			current.Reset()
		} else {
			current.WriteRune(char)
		}
	}

	if current.Len() > 0 {
		result = append(result, current.String())
	}

	return result
}

// GetDefaultAnimations returns a set of default animations
func (a *App) GetDefaultAnimations() AnimationConfig {
	return AnimationConfig{
		Beziers: []Bezier{
			{Name: "default", X0: "0.05", Y0: "0.9", X1: "0.1", Y1: "1.05"},
			{Name: "linear", X0: "0.0", Y0: "0.0", X1: "1.0", Y1: "1.0"},
			{Name: "easeInOutCubic", X0: "0.65", Y0: "0.05", X1: "0.36", Y1: "1.0"},
		},
		Animations: []Animation{
			{Name: "windows", Enabled: true, Speed: "8", Curve: "default", Style: "slide"},
			{Name: "windowsIn", Enabled: true, Speed: "8", Curve: "default", Style: "popin 80%"},
			{Name: "windowsOut", Enabled: true, Speed: "8", Curve: "default", Style: "slide"},
			{Name: "windowsMove", Enabled: true, Speed: "8", Curve: "default", Style: ""},
			{Name: "layers", Enabled: true, Speed: "8", Curve: "default", Style: "slide"},
			{Name: "fade", Enabled: true, Speed: "7", Curve: "default", Style: ""},
			{Name: "fadeIn", Enabled: true, Speed: "7", Curve: "default", Style: ""},
			{Name: "fadeOut", Enabled: true, Speed: "7", Curve: "default", Style: ""},
			{Name: "border", Enabled: true, Speed: "10", Curve: "default", Style: ""},
			{Name: "borderangle", Enabled: true, Speed: "8", Curve: "default", Style: "once"},
			{Name: "workspaces", Enabled: true, Speed: "6", Curve: "default", Style: "slide"},
		},
	}
}

// UpdateAnimation updates or adds a single animation
func (a *App) UpdateAnimation(anim Animation) error {
	config := a.ReadAnimations()

	// Find and update existing animation
	found := false
	for i, existing := range config.Animations {
		if existing.Name == anim.Name {
			config.Animations[i] = anim
			found = true
			break
		}
	}

	// Add new animation if not found
	if !found {
		config.Animations = append(config.Animations, anim)
	}

	return a.WriteAnimations(config)
}

// UpdateBezier updates or adds a single bezier curve
func (a *App) UpdateBezier(bez Bezier) error {
	config := a.ReadAnimations()

	// Find and update existing bezier
	found := false
	for i, existing := range config.Beziers {
		if existing.Name == bez.Name {
			config.Beziers[i] = bez
			found = true
			break
		}
	}

	// Add new bezier if not found
	if !found {
		config.Beziers = append(config.Beziers, bez)
	}

	return a.WriteAnimations(config)
}

// DeleteAnimation removes an animation by name
func (a *App) DeleteAnimation(name string) error {
	config := a.ReadAnimations()

	// Filter out the animation
	filtered := []Animation{}
	for _, anim := range config.Animations {
		if anim.Name != name {
			filtered = append(filtered, anim)
		}
	}

	config.Animations = filtered
	return a.WriteAnimations(config)
}

// DeleteBezier removes a bezier curve by name
func (a *App) DeleteBezier(name string) error {
	config := a.ReadAnimations()

	// Filter out the bezier
	filtered := []Bezier{}
	for _, bez := range config.Beziers {
		if bez.Name != name {
			filtered = append(filtered, bez)
		}
	}

	config.Beziers = filtered
	return a.WriteAnimations(config)
}

// ToggleAnimation toggles the comment state of an animation line
func (a *App) ToggleAnimation(name string) error {
	path := a.GetAnimationsPath()

	// Read the entire file
	content, err := os.ReadFile(path)
	if err != nil {
		return fmt.Errorf("failed to read file: %w", err)
	}

	lines := strings.Split(string(content), "\n")
	modified := false
	inAnimationBlock := false

	for i, line := range lines {
		trimmed := strings.TrimSpace(line)

		// Track if we're in the animations block
		if strings.HasPrefix(trimmed, "animations") && strings.Contains(trimmed, "{") {
			inAnimationBlock = true
			continue
		}
		if inAnimationBlock && strings.HasPrefix(trimmed, "}") {
			inAnimationBlock = false
			continue
		}

		// Only process lines within the animations block
		if !inAnimationBlock {
			continue
		}

		// Check if this is an animation line (commented or not)
		isCommented := strings.HasPrefix(trimmed, "#")
		actualLine := trimmed
		if isCommented {
			actualLine = strings.TrimSpace(strings.TrimPrefix(trimmed, "#"))
		}

		// Only process lines that start with "animation"
		if !strings.HasPrefix(actualLine, "animation") {
			continue
		}

		// Parse the animation name
		parts := strings.SplitN(actualLine, "=", 2)
		if len(parts) == 2 {
			animParts := splitByComma(strings.TrimSpace(parts[1]))
			if len(animParts) > 0 && strings.TrimSpace(animParts[0]) == name {
				// Toggle comment
				indent := getIndentation(line)
				if isCommented {
					// Uncomment
					lines[i] = indent + actualLine
				} else {
					// Comment
					lines[i] = indent + "# " + actualLine
				}
				modified = true
				break
			}
		}
	}

	if !modified {
		return fmt.Errorf("animation %s not found", name)
	}

	// Write back to file
	newContent := strings.Join(lines, "\n")
	if err := os.WriteFile(path, []byte(newContent), 0644); err != nil {
		return fmt.Errorf("failed to write file: %w", err)
	}

	return nil
}

// Helper function to get indentation from a line
func getIndentation(line string) string {
	for i, char := range line {
		if char != ' ' && char != '\t' {
			return line[:i]
		}
	}
	return ""
}
